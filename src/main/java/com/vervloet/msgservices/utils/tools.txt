        allPosts.forEach((post) -> {
            System.out.println(post.getVotes());
        });

Optional<Vote> userVote = votedList.stream().filter(vote -> vote.getUserId().equals(user.getId())).findFirst();

        if (userVote.isPresent()) {
            if (userVote.get().getTypeVote().equals(1)) {
                return new ResponseEntity<>("Already Upvoted", HttpStatus.CONFLICT);
            } else if (userVote.get().getTypeVote().equals(0)) {
                votedList.set(votedList.indexOf(userVote.get()),userVote.get().setTypeVoteAndReturn(1));
                post.setVotedList(votedList);
                post.setVotes(post.getVotes()+1L);
            } else {
                votedList.set(votedList.indexOf(userVote.get()),userVote.get().setTypeVoteAndReturn(1));
                post.setVotedList(votedList);
                post.setVotes(post.getVotes()+2L);
            }
        } else {
            votedList.add(new Vote(post.getId(), user.getId(), 1));
            post.setVotedList(votedList);
            post.setVotes(post.getVotes()+1L);
        }

        return new ResponseEntity<>("Upvoted Successfully", HttpStatus.OK);

        public ResponseEntity<?> downvotePost(Long postId) {

                Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();

                CustomUserDetails customUserDetails = ((CustomUserDetails)principal);

                User user = userRepository.findByEmail(customUserDetails.getUsername());

                Post post = postRepository.findById(postId)
                    .orElseThrow(() -> new ResourceNotFoundException("post", "id", postId));

                List<Vote> votedList = post.getVotedList();

                Optional<Vote> userVote = votedList.stream().filter(vote -> vote.getUserId().equals(user.getId())).findFirst();

                if (userVote.isPresent()) {
                    if (userVote.get().getTypeVote().equals(-1)) {
                        return new ResponseEntity<>("Already Downvoted", HttpStatus.CONFLICT);
                    } else if (userVote.get().getTypeVote().equals(0)) {
                        votedList.set(votedList.indexOf(userVote.get()),userVote.get().setTypeVoteAndReturn(-1));
                        post.setVotedList(votedList);
                        post.setVotes(post.getVotes()-1L);
                    } else {
                        votedList.set(votedList.indexOf(userVote.get()),userVote.get().setTypeVoteAndReturn(-1));
                        post.setVotedList(votedList);
                        post.setVotes(post.getVotes()-2L);
                    }
                } else {
                    votedList.add(new Vote(post.getId(), user.getId(), -1));
                    post.setVotedList(votedList);
                    post.setVotes(post.getVotes()-1L);
                }

                return new ResponseEntity<>("Downvoted Successfully", HttpStatus.OK);
            }
















            package com.vervloet.msgservices.domain.vo;

            import com.fasterxml.jackson.annotation.JsonProperty;
            import com.fasterxml.jackson.annotation.JsonPropertyOrder;
            import com.vervloet.msgservices.domain.vo.jsonapi.BaseJsonApiModel;
            import java.util.Optional;
            import java.util.Date;

            @JsonPropertyOrder(value = {"id", "content", "created", "post_path", "user_path"})
            public class CommentVo extends BaseJsonApiModel {

              @JsonProperty(value = "id")
              private Long id;

              @JsonProperty(value = "content")
              private String content;

              @JsonProperty(value = "created")
              private Date created;

              @JsonProperty(value = "post_path")
              private Long postPath;

              @JsonProperty(value = "user_path")
              private Long userPath;


              public CommentVo() {
              }

              public CommentVo(Builder builder) {
                Optional.ofNullable(builder.id).ifPresent(this::setId);
                Optional.ofNullable(builder.content).ifPresent(this::setContent);
                Optional.ofNullable(builder.created).ifPresent(this::setCreated);
                Optional.ofNullable(builder.postPath).ifPresent(this::setPostPath);
                Optional.ofNullable(builder.userPath).ifPresent(this::setUserPath);
              }

              public static Builder builder() {
                return new Builder();
              }

              public Long getId() {
                return id;
              }

              public void setId(Long id) {
                this.id = id;
              }

              public String getContent() {
                return content;
              }

              public void setContent(String content) {
                this.content = content;
              }

              public Date getCreated() {
                return created;
              }

              public void setCreated(Date created) {
                this.created = created;
              }

              public Long getPostPath() {
                return postPath;
              }

              public void setPostPath(Long postPath) {
                this.postPath = postPath;
              }

              public Long getUserPath() {
                return userPath;
              }

              public void setUserPath(Long userPath) {
                this.userPath = userPath;
              }

              @Override
              public String getTypeName() {
                return "comment";
              }

              @Override
              public Optional<String> baseUrl() {
                return Optional.of("/api/comment/" + getId());
              }


              public static final class Builder {

                private Long id;
                private String content;
                private Date created;
                private Long postPath;
                private Long userPath;

                public Builder withId(Long id) {
                  this.id = id;
                  return this;
                }

                public Builder withContent(String content) {
                  this.content = content;
                  return this;
                }

                public Builder withCreated(Date created) {
                  this.created = created;
                  return this;
                }

                public Builder withPostPath(Long postPath) {
                  this.postPath = postPath;
                  return this;
                }

                public Builder withUserPath(Long userPath) {
                  this.userPath = userPath;
                  return this;
                }

                public CommentVo build() {
                  return new CommentVo(this);
                }

              }
            }



    /*@ApiOperation(
        value = "Get user information.",
        tags = {"Pseudo Reddit API - Users"}
    )
    @GetMapping("/{userId}")
    public ResponseEntity<?> getUser(@PathVariable(value = "userId") Long userId) {

        return userService.getUser(userId);
    }

    @GetMapping()
    public ResponseEntity<?> getAllUsers(){

        return userService.getAllUsers();
    }*/